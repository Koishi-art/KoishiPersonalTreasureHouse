# 子集生成

### 位向量法

回忆如何计算子集数。一种算法是每一个元素只有选或者不选两个互斥的选择。对于一个序列Array [0 to n] ,可以用一个bool数组B[ 0 to n] 反应对应位置的元素有没有选择。

在一次决策之后，对下一个进行决策，这很容易令人想起递归。  

我们从某号位开始一个个决策，而之前的我们不考虑，它们应该是决策好了的。这就意味着形式参数应该包含一个起始位置b。

考虑到c++不能方便的得到array的长度，我们也应该提供尾部e

当我们形成好了一个子集，就可以输出它。这个时候应该是末尾决策好了的时候。

于是我们不难想到如下的代码：

```C++	
void output(bool* B ,int* Arr, int e)
{
    for (int i = 0; i <= e; i++)
    {
        if (B[i])printf("%d", Arr[i]);
    }
    printf("\n");
}
//核心
void solve(int b, int e, bool* B, int* arr)
{
    if (b == e + 1) 
    {
        //边界，我们是先b位决策再到b+1位，那么传入到e+1说明e位已经决策好了
        output(B, arr, e); return;
    }
    B[b] = false;
    solve(b + 1, e, B, arr);
    B[b] = true;
    solve(b + 1, e, B, arr);
    return;
}

int main(void)
{
    bool B[3] = { 0,0,0 };
    int m[3] = { 1,2,3 };
    solve(0, 2, B, m);
    return 0;
}
```

### 二进制法

既然一个bool数组可以反应取舍，那么何不利用一个整数这一天然的bool数组呢？尽管有时候这不够长，但是在够用的情况下，二进制法无疑会比位向量法更高效。

那么，仿照位向量法，我们对于一个数组array[0 to n ] (n<=你所用的数据类型的位数（指32 64）)

我们让000...01对应第0位，让100...00对应第n位，这样设计的理由一会儿就会不言而喻。

```c++
//输出(打印）函数
void output(int* arr, int n, int s)
{
    for (int i = 0; i < n; i++)
        //n是元素数，也就是数组长度，当然不能爆
    {
        if (s & (1 << i))printf("%d", arr[i]);
        /**
        这里可能是最难懂的；给定一个int类型的s，有32个bool值；
        1<<i表示左移运算，一般我们说k<<i指代k*2^i但是这次需要直接从二进制形式看
        00001=1，左移0位，就是00001，和s(假定二进制是01011)进行&运算
        发现得到00001，
        左移2位，就是00100，&运算得到00000
        发现了吗？
        00001的作用类似一个探针，只有s对应位是1才能在&运算里面得到非0数，因为除此之外的一切位		   都会是0。
        这样我们建立起第n位有没有选择和一个整数的联系
        这就是我们二进制数和数组位对应法则的理由
        */
    }
    printf("\n");
}
//枚举十分简单，从0（00...0）到2^n - 1(11...11)即可，不想要空集就从1开始
void solve(int n, int* arr)
{
    for (int i = 0; i < (1 << n); i++)
    {
        output(arr, n, i);
    }
}
int main(void) {
    int m[3] = { 1,2,3 };
    solve(3, m);
    return 0;
}
```



参考用书：《算法竞赛入门经典（第二版）》